<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Equity: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Equity
   </div>
   <div id="projectbrief">Bitcoin Protocol Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Copyright (c) 2009 Dave Gamble</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<h2>Welcome to <a class="el" href="structc_j_s_o_n.html">cJSON</a>. </h2>
<p><a class="el" href="structc_j_s_o_n.html">cJSON</a> aims to be the dumbest possible parser that you can get your job done with. It's a single file of C, and a single header file.</p>
<p>JSON is described best here: <a href="http://www.json.org/">http://www.json.org/</a> It's like XML, but fat-free. You use it to move data around, store things, or just generally represent your program's state.</p>
<p>First up, how do I build? Add cJSON.c to your project, and put <a class="el" href="c_j_s_o_n_8h_source.html">cJSON.h</a> somewhere in the header search path. For example, to build the test app: </p><pre class="fragment">gcc cJSON.c test.c -o test -lm
./test
</pre><p>As a library, <a class="el" href="structc_j_s_o_n.html">cJSON</a> exists to take away as much legwork as it can, but not get in your way. As a point of pragmatism (i.e. ignoring the truth), I'm going to say that you can use it in one of two modes: Auto and Manual. Let's have a quick run-through.</p>
<p>I lifted some JSON from this page: <a href="http://www.json.org/fatfree.html">http://www.json.org/fatfree.html</a> That page inspired me to write <a class="el" href="structc_j_s_o_n.html">cJSON</a>, which is a parser that tries to share the same philosophy as JSON itself. Simple, dumb, out of the way.</p>
<h2>Some JSON: </h2>
<pre class="fragment">{
    "name": "Jack (\"Bee\") Nimble", 
    "format": {
        "type":       "rect", 
        "width":      1920, 
        "height":     1080, 
        "interlace":  false, 
        "frame rate": 24
    }
}
</pre><p>Assume that you got this from a file, a webserver, or magic JSON elves, whatever, you have a char * to it. Everything is a <a class="el" href="structc_j_s_o_n.html">cJSON</a> struct. Get it parsed: </p><pre class="fragment">cJSON * root = cJSON_Parse(my_json_string);
</pre><p>This is an object. We're in C. We don't have objects. But we do have structs. What's the framerate? </p><pre class="fragment">cJSON * format = cJSON_GetObjectItem(root,"format");
int framerate = cJSON_GetObjectItem(format,"frame rate")-&gt;valueint;
</pre><p>Want to change the framerate? </p><pre class="fragment">cJSON_GetObjectItem(format,"frame rate")-&gt;valueint = 25;
</pre><p>Back to disk? </p><pre class="fragment">char * rendered = cJSON_Print(root);
</pre><p>Finished? Delete the root (this takes care of everything else). </p><pre class="fragment">cJSON_Delete(root);
</pre><p>That's AUTO mode. If you're going to use Auto mode, you really ought to check pointers before you dereference them. If you want to see how you'd build this struct in code? </p><pre class="fragment">cJSON *root,*fmt;
root = cJSON_CreateObject();  
cJSON_AddItemToObject(root, "name", cJSON_CreateString("Jack (\"Bee\") Nimble"));
cJSON_AddItemToObject(root, "format", fmt = cJSON_CreateObject());
cJSON_AddStringToObject(fmt, "type", "rect");
cJSON_AddNumberToObject(fmt, "width", 1920);
cJSON_AddNumberToObject(fmt, "height", 1080);
cJSON_AddFalseToObject (fmt, "interlace");
cJSON_AddNumberToObject(fmt, "frame rate", 24);
</pre><p>Hopefully we can agree that's not a lot of code? There's no overhead, no unnecessary setup. Look at test.c for a bunch of nice examples, mostly all ripped off the json.org site, and a few from elsewhere.</p>
<p>What about manual mode? First up you need some detail. Let's cover how the <a class="el" href="structc_j_s_o_n.html">cJSON</a> objects represent the JSON data. <a class="el" href="structc_j_s_o_n.html">cJSON</a> doesn't distinguish arrays from objects in handling; just type. Each <a class="el" href="structc_j_s_o_n.html">cJSON</a> has, potentially, a child, siblings, value, a name.</p>
<p>The root object has: Object Type and a Child The Child has name "name", with value "Jack ("Bee") Nimble", and a sibling: Sibling has type Object, name "format", and a child. That child has type String, name "type", value "rect", and a sibling: Sibling has type Number, name "width", value 1920, and a sibling: Sibling has type Number, name "height", value 1080, and a sibling: Sibling hs type False, name "interlace", and a sibling: Sibling has type Number, name "frame rate", value 24</p>
<h2>Here's the structure: </h2>
<pre class="fragment">typedef struct cJSON {
  struct cJSON *next,*prev;
  struct cJSON *child;

  int type;

  char *valuestring;
  int valueint;
  double valuedouble;

  char *string;
} cJSON;
</pre><p>By default all values are 0 unless set by virtue of being meaningful.</p>
<p>next/prev is a doubly linked list of siblings. next takes you to your sibling, prev takes you back from your sibling to you. Only objects and arrays have a "child", and it's the head of the doubly linked list. A "child" entry will have prev==0, but next potentially points on. The last sibling has next=0. The type expresses Null/True/False/Number/String/Array/Object, all of which are #defined in <a class="el" href="c_j_s_o_n_8h_source.html">cJSON.h</a></p>
<p>A Number has valueint and valuedouble. If you're expecting an int, read valueint, if not read valuedouble.</p>
<p>Any entry which is in the linked list which is the child of an object will have a "string" which is the "name" of the entry. When I said "name" in the above example, that's "string". "string" is the JSON name for the 'variable name' if you will.</p>
<p>Now you can trivially walk the lists, recursively, and parse as you please. You can invoke cJSON_Parse to get <a class="el" href="structc_j_s_o_n.html">cJSON</a> to parse for you, and then you can take the root object, and traverse the structure (which is, formally, an N-tree), and tokenise as you please. If you wanted to build a callback style parser, this is how you'd do it (just an example, since these things are very specific): </p><pre class="fragment">void parse_and_callback(cJSON *item,const char *prefix)
{
  while (item)
  {
    char *newprefix = malloc(strlen(prefix) + strlen(item-&gt;name) + 2);
    sprintf(newprefix,"%s/%s",prefix,item-&gt;name);
    int dorecurse = callback(newprefix, item-&gt;type, item);
    if (item-&gt;child &amp;&amp; dorecurse) parse_and_callback(item-&gt;child, newprefix);
    item = item-&gt;next;
    free(newprefix);
  }
}
</pre><p>The prefix process will build you a separated list, to simplify your callback handling. The 'dorecurse' flag would let the callback decide to handle sub-arrays on it's own, or let you invoke it per-item. For the item above, your callback might look like this: </p><pre class="fragment">int callback(const char *name,int type,cJSON *item)
{
  if (!strcmp(name,"name"))  { /* populate name */ }
  else if (!strcmp(name,"format/type")  { /* handle "rect" */ }
  else if (!strcmp(name,"format/width")  { /* 800 */ }
  else if (!strcmp(name,"format/height")  { /* 600 */ }
  else if (!strcmp(name,"format/interlace")  { /* false */ }
  else if (!strcmp(name,"format/frame rate")  { /* 24 */ }
  return 1;
}
</pre><p>Alternatively, you might like to parse iteratively. You'd use: </p><pre class="fragment">void parse_object(cJSON *item)
{
  int i;
  for (i = 0 ; i &lt; cJSON_GetArraySize(item) ; i++)
  {
    cJSON * subitem = cJSON_GetArrayItem(item, i);
    // handle subitem.  
  }
}
</pre><p>Or, for PROPER manual mode: </p><pre class="fragment">void parse_object(cJSON * item)
{
  cJSON *subitem = item-&gt;child;
  while (subitem)
  {
    // handle subitem
    if (subitem-&gt;child) parse_object(subitem-&gt;child);

    subitem = subitem-&gt;next;
  }
}
</pre><p>Of course, this should look familiar, since this is just a stripped-down version of the callback-parser.</p>
<p>This should cover most uses you'll find for parsing. The rest should be possible to infer.. and if in doubt, read the source! There's not a lot of it! ;)</p>
<p>In terms of constructing JSON data, the example code above is the right way to do it. You can, of course, hand your sub-objects to other functions to populate. Also, if you find a use for it, you can manually build the objects. For instance, suppose you wanted to build an array of objects? </p><pre class="fragment">cJSON * objects[24];

cJSON * Create_array_of_anything(cJSON ** items, int num)
{
  int i;
  cJSON * prev, * root = cJSON_CreateArray();
  for (i = 0 ; i &lt; 24 ; i++)
  {
    if (!i) root-&gt;child = objects[i];
    else prev-&gt;next = objects[i], objects[i]-&gt;prev = prev;
    prev = objects[i];
  }
  return root;
}
</pre><p>and simply: Create_array_of_anything(objects, 24);</p>
<p><a class="el" href="structc_j_s_o_n.html">cJSON</a> doesn't make any assumptions about what order you create things in. You can attach the objects, as above, and later add children to each of those objects.</p>
<p>As soon as you call cJSON_Print, it renders the structure to text.</p>
<p>The test.c code shows how to handle a bunch of typical cases. If you uncomment the code, it'll load, parse and print a bunch of test files, also from json.org, which are more complex than I'd care to try and stash into a const char array[].</p>
<h2>Enjoy cJSON! </h2>
<ul>
<li>Dave Gamble, Aug 2009 </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AsynchronousCache: AsynchronousCache&lt; Element, Key, Handle &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AsynchronousCache
   </div>
   <div id="projectbrief">Asynchronous Cache Interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_asynchronous_cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AsynchronousCache&lt; Element, Key, Handle &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Asynchronous Cache.  
 <a href="class_asynchronous_cache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_asynchronous_cache_8h_source.html">AsynchronousCache.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache_1_1_back_door.html">BackDoor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6ac2fb8d624d511719accaa6d24ab016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ac2fb8d624d511719accaa6d24ab016"></a>
typedef ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a></td></tr>
<tr class="memdesc:a6ac2fb8d624d511719accaa6d24ab016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the element stored in the cache. <br /></td></tr>
<tr class="separator:a6ac2fb8d624d511719accaa6d24ab016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d13dd5e1a950029e6c09f22a1c054be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d13dd5e1a950029e6c09f22a1c054be"></a>
typedef KeyType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a></td></tr>
<tr class="memdesc:a3d13dd5e1a950029e6c09f22a1c054be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the element key. <br /></td></tr>
<tr class="separator:a3d13dd5e1a950029e6c09f22a1c054be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765d9b20322c93012da028aa17aa6a81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a765d9b20322c93012da028aa17aa6a81"></a>
typedef HandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a></td></tr>
<tr class="memdesc:a765d9b20322c93012da028aa17aa6a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the internal element handle. <br /></td></tr>
<tr class="separator:a765d9b20322c93012da028aa17aa6a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac22d6405d0a1b5aadf4e4b6b6d7f8dc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac22d6405d0a1b5aadf4e4b6b6d7f8dc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#ac22d6405d0a1b5aadf4e4b6b6d7f8dc8">AsynchronousCache</a> ()</td></tr>
<tr class="memdesc:ac22d6405d0a1b5aadf4e4b6b6d7f8dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ac22d6405d0a1b5aadf4e4b6b6d7f8dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bb74909cf4fdce2367061f7bf68509"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a48bb74909cf4fdce2367061f7bf68509">Request</a> (<a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;key)</td></tr>
<tr class="memdesc:a48bb74909cf4fdce2367061f7bf68509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts loading a element through the cache.  <a href="#a48bb74909cf4fdce2367061f7bf68509">More...</a><br /></td></tr>
<tr class="separator:a48bb74909cf4fdce2367061f7bf68509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a552a1a5f468a2841d4be68a5eb4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a266a552a1a5f468a2841d4be68a5eb4f">Prefetch</a> (<a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;key)</td></tr>
<tr class="memdesc:a266a552a1a5f468a2841d4be68a5eb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the cache that this element may be needed soon.  <a href="#a266a552a1a5f468a2841d4be68a5eb4f">More...</a><br /></td></tr>
<tr class="separator:a266a552a1a5f468a2841d4be68a5eb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9158682af0327bbd7ab52c0c1284abe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a9158682af0327bbd7ab52c0c1284abe6">Get</a> (<a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;key)</td></tr>
<tr class="memdesc:a9158682af0327bbd7ab52c0c1284abe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to an element in the cache (or nullptr if it is not in the cache)  <a href="#a9158682af0327bbd7ab52c0c1284abe6">More...</a><br /></td></tr>
<tr class="separator:a9158682af0327bbd7ab52c0c1284abe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b4122140d3f8d3c8b97ca5747125f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#ae72b4122140d3f8d3c8b97ca5747125f">Release</a> (<a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;key, bool forceEviction=false)</td></tr>
<tr class="memdesc:ae72b4122140d3f8d3c8b97ca5747125f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entry in the cache and marks it as no longer used (optionally force eviction)  <a href="#ae72b4122140d3f8d3c8b97ca5747125f">More...</a><br /></td></tr>
<tr class="separator:ae72b4122140d3f8d3c8b97ca5747125f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04569cce90536c118789fb2b7193d51c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a04569cce90536c118789fb2b7193d51c">Release</a> (<a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a> const *pElement, bool forceEviction=false)</td></tr>
<tr class="memdesc:a04569cce90536c118789fb2b7193d51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entry in the cache and marks it as no longer used (optionally force eviction)  <a href="#a04569cce90536c118789fb2b7193d51c">More...</a><br /></td></tr>
<tr class="separator:a04569cce90536c118789fb2b7193d51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755e3e7db68c113a47d62d3df72ffee5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a755e3e7db68c113a47d62d3df72ffee5">IsEmpty</a> () const </td></tr>
<tr class="memdesc:a755e3e7db68c113a47d62d3df72ffee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the cache is empty (and no entries are being loaded)  <a href="#a755e3e7db68c113a47d62d3df72ffee5">More...</a><br /></td></tr>
<tr class="separator:a755e3e7db68c113a47d62d3df72ffee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ef82b5e803039b21e8639ba52e3acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a12ef82b5e803039b21e8639ba52e3acc">Clear</a> ()</td></tr>
<tr class="memdesc:a12ef82b5e803039b21e8639ba52e3acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the cache.  <a href="#a12ef82b5e803039b21e8639ba52e3acc">More...</a><br /></td></tr>
<tr class="separator:a12ef82b5e803039b21e8639ba52e3acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82baf7553e85c9f03fee1cf82ab3d459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a82baf7553e85c9f03fee1cf82ab3d459">IsCached</a> (<a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;key) const </td></tr>
<tr class="memdesc:a82baf7553e85c9f03fee1cf82ab3d459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the element is in the cache (though possibly released)  <a href="#a82baf7553e85c9f03fee1cf82ab3d459">More...</a><br /></td></tr>
<tr class="separator:a82baf7553e85c9f03fee1cf82ab3d459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af3ccacfc06f40e5e302d8afeed1df30a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3ccacfc06f40e5e302d8afeed1df30a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AsynchronousCache</b> (<a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a> const &amp;)=delete</td></tr>
<tr class="separator:af3ccacfc06f40e5e302d8afeed1df30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b12adfc5d15f30b91add9d9381ed4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87b12adfc5d15f30b91add9d9381ed4d"></a>
<a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a> const &amp;)=delete</td></tr>
<tr class="separator:a87b12adfc5d15f30b91add9d9381ed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6d8d00a74099e286409c6a24d70056"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a0a6d8d00a74099e286409c6a24d70056">Load</a> (<a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;key)=0</td></tr>
<tr class="memdesc:a0a6d8d00a74099e286409c6a24d70056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts loading an element with the specified key.  <a href="#a0a6d8d00a74099e286409c6a24d70056">More...</a><br /></td></tr>
<tr class="separator:a0a6d8d00a74099e286409c6a24d70056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aa5ec5172850a6973a2a6522e5bae2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a71aa5ec5172850a6973a2a6522e5bae2">Unload</a> (<a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> const &amp;handle)=0</td></tr>
<tr class="memdesc:a71aa5ec5172850a6973a2a6522e5bae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately unloads an element.  <a href="#a71aa5ec5172850a6973a2a6522e5bae2">More...</a><br /></td></tr>
<tr class="separator:a71aa5ec5172850a6973a2a6522e5bae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131017d0256a0136042b5e4128b5d2e9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#a131017d0256a0136042b5e4128b5d2e9">HasRoomFor</a> (<a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;key)=0</td></tr>
<tr class="memdesc:a131017d0256a0136042b5e4128b5d2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is room for an entry.  <a href="#a131017d0256a0136042b5e4128b5d2e9">More...</a><br /></td></tr>
<tr class="separator:a131017d0256a0136042b5e4128b5d2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30101ba69f3aec1632609823d47d276"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_asynchronous_cache.html#ac30101ba69f3aec1632609823d47d276">GetElement</a> (<a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> const &amp;handle)=0</td></tr>
<tr class="memdesc:ac30101ba69f3aec1632609823d47d276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of a loaded element, or nullptr.  <a href="#ac30101ba69f3aec1632609823d47d276">More...</a><br /></td></tr>
<tr class="separator:ac30101ba69f3aec1632609823d47d276"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Element, typename Key, typename Handle = void *&gt;<br />
class AsynchronousCache&lt; Element, Key, Handle &gt;</h3>

<p>Asynchronous Cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Element</td><td>Type of the elements stored in the cache </td></tr>
    <tr><td class="paramname">Key</td><td>Type of a key for accessing an element in the cache KeyType must implement operator==(). </td></tr>
    <tr><td class="paramname">Handle</td><td>Type of an element handle. This is the type of the value returned by <a class="el" href="class_asynchronous_cache.html#a0a6d8d00a74099e286409c6a24d70056" title="Starts loading an element with the specified key. ">Load()</a>. The default type is <code>void *</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This class is an abstract base class and must be derived from in order to be used. </dd>
<dd>
This class (and any derived from it) cannot be copied or assigned.</dd></dl>
<p>This class provides an asynchronous caching mechanism interface. It has the following characteristics:</p><ul>
<li>When an element is requested, it will be available sometime in the future.</li>
<li>Elements must be explicitly released.</li>
<li>A released element remains in the cache until it is evicted to make room for another element or the cache is explicitly told to evict it. An evicted element is removed from the cache entirely.</li>
<li>A request may fail if there is not enough room in the cache.</li>
<li>An element may be "prefetched". A prefetched element is loaded and immediately released so that it is in the cache, but it must still be requested.</li>
</ul>
<p>Implementation:</p>
<p>The actual cache storage is implemented in the derived class. This class provides a standard interface and manages the storage according to the behaviors described above.</p>
<p>When deriving from this class, the following member functions must be overloaded:</p><ul>
<li><a class="el" href="class_asynchronous_cache.html#a0a6d8d00a74099e286409c6a24d70056" title="Starts loading an element with the specified key. ">Load()</a></li>
<li><a class="el" href="class_asynchronous_cache.html#a71aa5ec5172850a6973a2a6522e5bae2" title="Immediately unloads an element. ">Unload()</a></li>
<li><a class="el" href="class_asynchronous_cache.html#a131017d0256a0136042b5e4128b5d2e9" title="Returns true if there is room for an entry. ">HasRoomFor()</a></li>
<li><a class="el" href="class_asynchronous_cache.html#ac30101ba69f3aec1632609823d47d276" title="Returns the address of a loaded element, or nullptr. ">GetElement()</a></li>
</ul>
<p>The requirements for these functions are listed in the functions' documentation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a12ef82b5e803039b21e8639ba52e3acc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the cache. </p>
<p>This function evicts all entries from the cache. An "evicted" element is removed from the cache entirely. </p>

</div>
</div>
<a class="anchor" id="a9158682af0327bbd7ab52c0c1284abe6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a> * <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to an element in the cache (or nullptr if it is not in the cache) </p>
<p>This function returns a pointer to an element in the cache.</p>
<p>After an element is requested, <a class="el" href="class_asynchronous_cache.html#a9158682af0327bbd7ab52c0c1284abe6" title="Returns a pointer to an element in the cache (or nullptr if it is not in the cache) ...">Get()</a> will return 0 until the element is available. An element that has never been requested will always return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Element to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the element, or 0 if the element is not in the cache. </dd></dl>

</div>
</div>
<a class="anchor" id="ac30101ba69f3aec1632609823d47d276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle  = void *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>* <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::GetElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> const &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the address of a loaded element, or nullptr. </p>
<p>This function returns the address of an element if it is loaded. If it is not loaded (or still loading) the function returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle of the element to get </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a131017d0256a0136042b5e4128b5d2e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle  = void *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::HasRoomFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there is room for an entry. </p>
<p>This function tells if there is room in the cache storage to load the specified entry. The cache manager relies completely on the value returned by this function &ndash; no other information is used. When an element is requested, the cache first calls this function to determine if there is room for it. If not, it may repeatedly unload elements and check if there is room until this function returns <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key identifying the element to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if the cache storage has room for the specified element </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be overridden. </dd></dl>

</div>
</div>
<a class="anchor" id="a82baf7553e85c9f03fee1cf82ab3d459"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::IsCached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the element is in the cache (though possibly released) </p>
<p>This function returns <code>true</code> if the specified element is in the cache, even if it is released.</p>
<p>Elements that are loading or prefetching will return <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Element to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a755e3e7db68c113a47d62d3df72ffee5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the cache is empty (and no entries are being loaded) </p>
<p>This function returns <code>true</code> if there are no elements in the cache (whether active or released). </p>

</div>
</div>
<a class="anchor" id="a0a6d8d00a74099e286409c6a24d70056"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle  = void *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::Load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts loading an element with the specified key. </p>
<p>When an element is requested, the cache will call this function to load it. The handle that is returned is used as a parameter when unloading the element or checking if it is loaded. Its value is completely determined by the derived class and the cache makes no attempt to interpret its value. The handle is intended to provide an efficient and effective way to reference a loaded element directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key identifying the element to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle used to identify the loaded element. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be overridden. </dd></dl>

</div>
</div>
<a class="anchor" id="a266a552a1a5f468a2841d4be68a5eb4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::Prefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies the cache that this element may be needed soon. </p>
<p>This function starts loading a element into the cache, however it is not available until it is also requested.</p>
<p>If a prefetched element is released before it is loaded, the load is canceled. The element may not be loaded if there is no room in the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Element to prefetch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Prefetching an available, requested, or prefetched element does nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="ae72b4122140d3f8d3c8b97ca5747125f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::Release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceEviction</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an entry in the cache and marks it as no longer used (optionally force eviction) </p>
<p>This function "releases" a cache element.</p>
<p>Once the element is released, it is no longer usable and may be evicted from the cache at any time. Elements must be released in order to be evicted from the cache. If the cache has a limited size, then elements must be released in order to make room for new elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Element to release </td></tr>
    <tr><td class="paramname">forceEviction</td><td>If <code>true</code>, the element is immediately removed from the cache storage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Releasing a released element by key does nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a04569cce90536c118789fb2b7193d51c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::Release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a> const *&#160;</td>
          <td class="paramname"><em>pElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceEviction</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an entry in the cache and marks it as no longer used (optionally force eviction) </p>
<p>This function "releases" a cache element.</p>
<p>Once the element is released, it is no longer usable and may be evicted from the cache at any time. Elements must be released in order to be evicted from the cache. If the cache has a limited size, then elements must be released in order to make room for new elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pElement</td><td>Element to release </td></tr>
    <tr><td class="paramname">forceEviction</td><td>If <code>true</code>, the element is immediately removed from the cache storage.</td></tr>
  </table>
  </dd>
</dl>
<p>Addresses are not unique, so specifying the address of a previously released element may release a different element. </p>

</div>
</div>
<a class="anchor" id="a48bb74909cf4fdce2367061f7bf68509"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::Request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts loading a element through the cache. </p>
<p>This function starts loading a element into the cache.</p>
<p>When it is available, <a class="el" href="class_asynchronous_cache.html#a9158682af0327bbd7ab52c0c1284abe6" title="Returns a pointer to an element in the cache (or nullptr if it is not in the cache) ...">Get()</a> will returns a pointer to it, but until then, <a class="el" href="class_asynchronous_cache.html#a9158682af0327bbd7ab52c0c1284abe6" title="Returns a pointer to an element in the cache (or nullptr if it is not in the cache) ...">Get()</a> will return 0. If a requested element is released before it is loaded, the request will be canceled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Element to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code>, if there is no room in the cache to load the element</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requesting an available or requested element does nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a71aa5ec5172850a6973a2a6522e5bae2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element , typename Key , typename Handle  = void *&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_asynchronous_cache.html">AsynchronousCache</a>&lt; <a class="el" href="class_asynchronous_cache.html#a6ac2fb8d624d511719accaa6d24ab016">Element</a>, <a class="el" href="class_asynchronous_cache.html#a3d13dd5e1a950029e6c09f22a1c054be">Key</a>, <a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> &gt;::Unload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_asynchronous_cache.html#a765d9b20322c93012da028aa17aa6a81">Handle</a> const &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immediately unloads an element. </p>
<p>When the cache decides to unload an element (in order to make room for another or when explicitly told), this function will be called with the element's handle to unload the element. If the element is currently in the the process of loading, the load must be canceled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle identifying the entry to unload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function must be overridden. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_asynchronous_cache_8h_source.html">AsynchronousCache.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>

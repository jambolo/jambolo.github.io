<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Buffer: BufferedProxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Buffer
   </div>
   <div id="projectbrief">Stream Buffer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_buffered_proxy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BufferedProxy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A stream buffer that enables non-aligned and non-blocksize I/O to/from an object that requires aligned and/or block I/O or requires I/O to/from a specific memory location.  
 <a href="class_buffered_proxy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_buffer_8h_source.html">Buffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy_1_1_buffered_object.html">BufferedObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffered object.  <a href="class_buffered_proxy_1_1_buffered_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a50097f39e26efe9170d4e8e3ebcf6741"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="class_buffered_proxy.html#a50097f39e26efe9170d4e8e3ebcf6741ac42f3077f5334a5d3083e29fa97dcfcb">CF_READ_ONLY</a> = 0x00000001, 
<a class="el" href="class_buffered_proxy.html#a50097f39e26efe9170d4e8e3ebcf6741ab48ff2f4556dcee042117c6579857896">CF_WRITE_ONLY</a> = 0x00000002, 
<a class="el" href="class_buffered_proxy.html#a50097f39e26efe9170d4e8e3ebcf6741ab4769cdb3b756c4819b139ca9e01a1a6">CF_NO_DIRECT_IO</a> = 0x00000004, 
<a class="el" href="class_buffered_proxy.html#a50097f39e26efe9170d4e8e3ebcf6741a1b18bb4549097755791d5ade5390753b">CF_NO_FILLS</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="class_buffered_proxy.html#a50097f39e26efe9170d4e8e3ebcf6741a5d6041ce8d777cd1b73b8f587a443eb3">CF_RANDOM_ACCESS</a> = 0x00000010
<br />
 }<tr class="memdesc:a50097f39e26efe9170d4e8e3ebcf6741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration flags.  <a href="class_buffered_proxy.html#a50097f39e26efe9170d4e8e3ebcf6741">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a50097f39e26efe9170d4e8e3ebcf6741"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ef553f72030ad182476d9ffdb96b49e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy.html#a5ef553f72030ad182476d9ffdb96b49e">BufferedProxy</a> (void *pBuffer, int bufferSize, unsigned handle, <a class="el" href="class_buffered_proxy_1_1_buffered_object.html">BufferedObject</a> *pBufferedObject, unsigned flags, int blockSize=1, unsigned sectorAlign=1, unsigned bufferAlign=1)</td></tr>
<tr class="memdesc:a5ef553f72030ad182476d9ffdb96b49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a5ef553f72030ad182476d9ffdb96b49e">More...</a><br /></td></tr>
<tr class="separator:a5ef553f72030ad182476d9ffdb96b49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9389fc06b3cd8e19bd52cfc0333509d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9389fc06b3cd8e19bd52cfc0333509d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy.html#aa9389fc06b3cd8e19bd52cfc0333509d">RemainingWriteSpace</a> () const </td></tr>
<tr class="memdesc:aa9389fc06b3cd8e19bd52cfc0333509d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes that can be written before the buffer will have to be flushed. <br /></td></tr>
<tr class="separator:aa9389fc06b3cd8e19bd52cfc0333509d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83081dc17b3dc1079b42ab947572b394"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83081dc17b3dc1079b42ab947572b394"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy.html#a83081dc17b3dc1079b42ab947572b394">RemainingReadAmount</a> () const </td></tr>
<tr class="memdesc:a83081dc17b3dc1079b42ab947572b394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes that can be read before the buffer will have to be filled. <br /></td></tr>
<tr class="separator:a83081dc17b3dc1079b42ab947572b394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad184af01d569c421dccbec6ebd24253c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy.html#ad184af01d569c421dccbec6ebd24253c">Read</a> (void *pDst, int n)</td></tr>
<tr class="memdesc:ad184af01d569c421dccbec6ebd24253c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads <em>n</em> bytes from the buffered object through the buffer. Returns the number of bytes read, or &lt; 0 if there is an error.  <a href="#ad184af01d569c421dccbec6ebd24253c">More...</a><br /></td></tr>
<tr class="separator:ad184af01d569c421dccbec6ebd24253c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cf8c02f9378b11ec49af9b854f2266"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy.html#af0cf8c02f9378b11ec49af9b854f2266">Write</a> (void const *pSrc, int n)</td></tr>
<tr class="memdesc:af0cf8c02f9378b11ec49af9b854f2266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes <em>n</em> bytes to the buffered object through the buffer. Returns the number of bytes written, or &lt; 0 if there is an error.  <a href="#af0cf8c02f9378b11ec49af9b854f2266">More...</a><br /></td></tr>
<tr class="separator:af0cf8c02f9378b11ec49af9b854f2266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29042697d682a74bb0b759fa4bc09e0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy.html#a29042697d682a74bb0b759fa4bc09e0e">Seek</a> (int location)</td></tr>
<tr class="memdesc:a29042697d682a74bb0b759fa4bc09e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the current location in the buffered object. Returns the actual location, or &lt; 0 if there is an error.  <a href="#a29042697d682a74bb0b759fa4bc09e0e">More...</a><br /></td></tr>
<tr class="separator:a29042697d682a74bb0b759fa4bc09e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc876ca8f389b2a31de9baddddd92a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cc876ca8f389b2a31de9baddddd92a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy.html#a9cc876ca8f389b2a31de9baddddd92a2">Flush</a> ()</td></tr>
<tr class="memdesc:a9cc876ca8f389b2a31de9baddddd92a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the buffer to flush any unwritten data to the buffered object. <br /></td></tr>
<tr class="separator:a9cc876ca8f389b2a31de9baddddd92a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd87f6756acdd48f42e8f55b3817d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_buffered_proxy.html#aefd87f6756acdd48f42e8f55b3817d6d">Fill</a> ()</td></tr>
<tr class="memdesc:aefd87f6756acdd48f42e8f55b3817d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the buffer to refresh itself from the buffered object.  <a href="#aefd87f6756acdd48f42e8f55b3817d6d">More...</a><br /></td></tr>
<tr class="separator:aefd87f6756acdd48f42e8f55b3817d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A stream buffer that enables non-aligned and non-blocksize I/O to/from an object that requires aligned and/or block I/O or requires I/O to/from a specific memory location. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a50097f39e26efe9170d4e8e3ebcf6741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configuration flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a50097f39e26efe9170d4e8e3ebcf6741ac42f3077f5334a5d3083e29fa97dcfcb"></a>CF_READ_ONLY&#160;</td><td class="fielddoc">
<p>The buffer normally assumes that both reading and writing will be performed. </p>
<p>Performance can be improved when I/O is one or the other, but not both. Allow only reads </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a50097f39e26efe9170d4e8e3ebcf6741ab48ff2f4556dcee042117c6579857896"></a>CF_WRITE_ONLY&#160;</td><td class="fielddoc">
<p>Allow only writes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a50097f39e26efe9170d4e8e3ebcf6741ab4769cdb3b756c4819b139ca9e01a1a6"></a>CF_NO_DIRECT_IO&#160;</td><td class="fielddoc">
<p>In order to improve performance, reads and writes that are larger than the size of the buffer normally bypass the buffer (as long as the data can be properly aligned). </p>
<p>Sometimes, this is not desirable (e.g. when the buffered object can only access a restricted address space). This flag means always do reads and writes indirectly through the buffer. Never bypass the buffer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a50097f39e26efe9170d4e8e3ebcf6741a1b18bb4549097755791d5ade5390753b"></a>CF_NO_FILLS&#160;</td><td class="fielddoc">
<p>In order to support read and update, the buffer is normally filled with data from the buffered object whenever a location is accessed that is not already in the buffer. </p>
<p>This behavior is unnecessary in many cases. This flag improves performance by indicating the buffer should never be filled from the buffered object. Never fill the buffer from the buffered object. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a50097f39e26efe9170d4e8e3ebcf6741a5d6041ce8d777cd1b73b8f587a443eb3"></a>CF_RANDOM_ACCESS&#160;</td><td class="fielddoc">
<p>The buffer normally assumes that most I/O is sequential or reads are larger than the size of a buffer. </p>
<p>If that is not the case, the buffer may perform many unnecessary fills. This flag improves performance when the I/O is mostly random and the size of the reads are usually smaller than the size of the buffer. Assume mostly random access </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5ef553f72030ad182476d9ffdb96b49e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BufferedProxy::BufferedProxy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_buffered_proxy_1_1_buffered_object.html">BufferedObject</a> *&#160;</td>
          <td class="paramname"><em>pBufferedObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sectorAlign</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bufferAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>Memory for use by the buffer. The address must be aligned on a <em>bufferAlign</em> boundary. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size of the buffer. It must be a multiple of <em>blockSize</em>. </td></tr>
    <tr><td class="paramname">handle</td><td>Handle to be passed to the buffered object. </td></tr>
    <tr><td class="paramname">pBufferedObject</td><td>Interface to the object that fills and flushes the buffer. </td></tr>
    <tr><td class="paramname">flags</td><td>Configuration flags (see enum Flags) </td></tr>
    <tr><td class="paramname">blockSize</td><td>The buffered object will always be asked to fill or flush a multiple of this size. </td></tr>
    <tr><td class="paramname">sectorAlign</td><td>Locations in the buffered object are always aligned on this boundary. This value must be a power of two. If the sector alignment is higher than the block size, then the sector alignment must be a multiple of the block size. If the block size is higher than sector alignment, then the opposite must be true. </td></tr>
    <tr><td class="paramname">bufferAlign</td><td>The buffered object is always asked to fill or flush starting at an memory address aligned on this boundary. This value must be a power of two. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aefd87f6756acdd48f42e8f55b3817d6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufferedProxy::Fill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the buffer to refresh itself from the buffered object. </p>
<dl class="section warning"><dt>Warning</dt><dd>Any data in the buffer that has not been flushed will be overwritten. </dd></dl>

</div>
</div>
<a class="anchor" id="ad184af01d569c421dccbec6ebd24253c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BufferedProxy::Read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads <em>n</em> bytes from the buffered object through the buffer. Returns the number of bytes read, or &lt; 0 if there is an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDst</td><td>Location to which data is to be copied from the buffer </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read. </dd></dl>

</div>
</div>
<a class="anchor" id="a29042697d682a74bb0b759fa4bc09e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BufferedProxy::Seek </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the current location in the buffered object. Returns the actual location, or &lt; 0 if there is an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>Where to put the current location (specified as the number of bytes from the beginning). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0cf8c02f9378b11ec49af9b854f2266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BufferedProxy::Write </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes <em>n</em> bytes to the buffered object through the buffer. Returns the number of bytes written, or &lt; 0 if there is an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSrc</td><td>Location from which data is to be copied to the buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual number of bytes written </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_buffer_8h_source.html">Buffer.h</a></li>
<li>Buffer.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
